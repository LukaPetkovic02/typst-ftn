= Имплементација

У овом делу приказане су 3 независне имплементације система за
симулацију двоструког клатна: у програмским језицима _Python_, _Rust_, и _Go_.
Свака имплементација прати исти нумерички модел и _RK4_ методу, али се разликује
у начину организације паралелног извршавања, управљања меморијом и комуникације
између процеса.

== Имплементација у програмском језику Python

=== Увод и очекивања

_Python_ је изабран као полазна тачка за развој система због своје једноставности и изражајности.
Иако је _Python_ интерпретиран језик и самим тим спорији од компајлираних (попут _Rust_ и _Go_),
његова синтакса и подршка за паралелно програмирање (преко `multiprocessing` модула) омогућују
брз развој и лако експериментисање са различитим моделима извршавања.

Главни циљ ове имплементације био је да се добије референтно, једноставно и прегледно решење
које ће послужити као основа за каснија поређења.

=== Секвенцијална верзија

_Python_ имплементација се састоји из три главна дела:
1. *Runge–Kutta интегратор* — врши један корак нумеричке интеграције;
2. *Функција за интеграцију кроз време* — управља низом корака и бележи резултате;
3. *Физички модел система* — израчунава изведене величине и енергију система.

#figure(
  ```python
  def rk4_step(y, dt, f, params):
    k1 = f(y, params)
    k2 = f(y + 0.5 * dt * k1, params)
    k3 = f(y + 0.5 * dt * k2, params)
    k4 = f(y + dt * k3, params)
    return y + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)
  ```,
  caption: [Функција Runge–Kutta корака у Python-у]
)


#figure(
  ```python
  def integrate(y0, dt, steps, f, params, record_energy_fn=None):
    y = np.array(y0, dtype=float).copy()
    traj = np.zeros((steps + 1, y.size))
    times = np.zeros(steps + 1)
    energies = None
    if record_energy_fn:
        energies = np.zeros(steps + 1)

    traj[0] = y
    if energies is not None:
        energies[0] = record_energy_fn(y, params)

    for i in range(1, steps + 1):
        y = rk4_step(y, dt, f, params)
        traj[i] = y
        times[i] = i * dt
        if energies is not None:
            energies[i] = record_energy_fn(y, params)

    return times, traj, energies
  ```,
  caption: [Функција за интеграцију кроз време]
)


#figure(
  ```python
  def integrate(y0, dt, steps, f, params, record_energy_fn=None):
      y = np.array(y0, dtype=float).copy()
      traj = np.zeros((steps + 1, y.size))
      times = np.zeros(steps + 1)
      energies = None
      if record_energy_fn:
          energies = np.zeros(steps + 1)

      traj[0] = y
      if energies is not None:
          energies[0] = record_energy_fn(y, params)

      for i in range(1, steps + 1):
          y = rk4_step(y, dt, f, params)
          traj[i] = y
          times[i] = i * dt
          if energies is not None:
              energies[i] = record_energy_fn(y, params)

      return times, traj, energies

    def energy(state, params):
        theta1, omega1, theta2, omega2 = state
        m1 = params.get("m1", 1.0)
        m2 = params.get("m2", 1.0)
        l1 = params.get("l1", 1.0)
        l2 = params.get("l2", 1.0)
        g  = params.get("g", 9.81)

        x1 = l1 * np.sin(theta1)
        y1 = -l1 * np.cos(theta1)
        x2 = x1 + l2 * np.sin(theta2)
        y2 = y1 - l2 * np.cos(theta2)

        v1x = l1 * omega1 * np.cos(theta1)
        v1y = l1 * omega1 * np.sin(theta1)
        v2x = v1x + l2 * omega2 * np.cos(theta2)
        v2y = v1y + l2 * omega2 * np.sin(theta2)

        T = 0.5 * m1 * (v1x**2 + v1y**2) + 0.5 * m2 * (v2x**2 + v2y**2)
        V = m1 * g * y1 + m2 * g * y2

        return T + V
  ```,
  caption: [Рачунање изведених величина и енергије система]
)

=== Паралелна имплементација

Да би се постигло брже извршавање симулација над већим бројем почетних услова,
_Python_ користи `multiprocessing`, који омогућава
паралелно извршавање процеса на више језгара.  
Свака симулација добија различит скуп почетних углова и угаоних брзина, 
а резултати се прикупљају по завршетку свих процеса.

Овим приступом свака симулација ради независно, без потребе за синхронизацијом,
јер сваки процес има сопствени интерпретер и меморијски простор, чиме се спречава глобално закључавање интерпретера (GIL).

=== Експерименти јаког и слабог скалирања

Да би се испитала скалабилност _Python_ имплементације, извршена су два скупа тестова.

- *Јако скалирање:* број временских корака остаје фиксиран, 
  а број процеса се мења (1, 2, 4, 8, 16).  
  Циљ је да се измери убрзање дефинисано као $S_p = T_1 / T_p$, где је $T_p$
  време извршавања са _p_ процесора.

- *Слабо скалирање:* сваки процес има константан број корака, 
  док укупан број корака расте пропорционално броју процесора.  
  Циљ је да се провери да ли време извршавања остаје приближно константно 
  када се посао равномерно дели на више јединица.

Резултати оба експеримента биће приказани у наредном поглављу, 
где ће се поредити _Python_, _Rust_ и _Go_ имплементације.

== Имплементација у програмском језику Rust

=== Увод и мотивација

_Rust_ је познат по својој способности да комбинује високе перформансе 
(сличне C/C++ језицима) са снажним системом типова и гаранцијама безбедности меморије.  
У контексту симулације двоструког клатна, Rust омогућава оптимално управљање меморијом, 
паралелно извршавање без _data race_-ова, и ефикасну обраду великих скупова података.  

Rust имплементација служи као пример како се исти нумерички модел 
може реализовати у језику нижег нивоа уз максималну ефикасност.  

=== Секвенцијална верзија

Секвенцијална имплементација у _Rust_-у користи исту _Runge–Kutta_ методу четвртог реда (RK4) 
као и Python, али је прилагођена строгом систему типова и статичком управљању меморијом.

=== Паралелна верзија

Паралелна имплементација заснива се на употреби `rayon` библиотеке. Она омогућава декларативну обраду
података у више нити без потребе за ручном синхронизацијом. Свака симулација представља засебан задатак 
са различитим почетним условима, што омогућава готово идеално скалирање са бројем језгара.

Имплементација користи структуру `Params` за складиштење физичких параметара 
система (масе, дужине и гравитације), док се стање система чува у низу 
дужине 4 (_θ₁, ω₁, θ₂, ω₂_). Свака нит извршава интеграцију Runge–Kutta методом 
за свој скуп почетних услова.

#figure(
  ```rust
  use rayon::prelude::*;
  use std::time::Instant;

  #[derive(Clone, Copy)]
  struct Params {
      m1: f64, m2: f64,
      l1: f64, l2: f64,
      g: f64,
  }

  ...

  fn main() {
    let mut runs = 8usize;
    let mut steps = 600_000;
    for arg in std::env::args().skip(1) {
        if let Some(v) = arg.strip_prefix("--runs=") { runs = v.parse().unwrap(); }
        if let Some(v) = arg.strip_prefix("--steps="){ steps = v.parse().unwrap(); }
    }

    let dt = 0.001;
    let params = Params{ m1:1.0, m2:1.0, l1:1.0, l2:1.0, g:9.81 };
    let base = [std::f64::consts::FRAC_PI_2, 0.0, std::f64::consts::FRAC_PI_2+0.01, 0.0];

    println!("Pokrećem {runs} paralelnih simulacija (steps={steps})...");
    let start_all = Instant::now();

    (0..runs).into_par_iter().for_each(|i| {
        let mut y0 = base;
        y0[2] += (i as f64 - runs as f64/2.0) * 1e-3;
        let _ = {
            let mut y = y0;
            for _ in 0..steps { y = rk4_step(&y, dt, &params); }
        };
    });

    let total = start_all.elapsed().as_secs_f64();
    println!("Paralelno (runs={runs}, steps={steps}) za {:.4}s", total);
}
  ``` ,
  caption: [Главни део паралелне имплементације помоћу _Rayon_ библиотеке]
)

У _main_ методи можемо приметити како `into_par_iter()` аутоматски дели посао на доступна језгра, док _Rayon runtime_ 
брине о балансирaњу оптерећења и поновној употреби радних нити.  
Мерењем времена извршавања показано је да Rust имплементација постиже најбоље резултате у односу на остала решења, што ће бити детаљније анализирано у наредном поглављу.

== Имплементација у програмском језику Go

=== Увод и мотивација

_Go_ је изабран као трећи приступ због своје једноставности, брзине компилације и уграђене подршке за конкурентно извршавање.  
Он комбинује синтаксну једноставност са снажним моделом конкурентности заснованим на _goroutines_ @geeksforgeeks2025goroutines и _channels_.  
Овај модел омогућава развој програма који користе више језгара без експлицитног управљања нитима, што га чини идеалним за паралелне симулације.

У контексту овог рада, _Go_ имплементација двоструког клатна представља *баланс* између брзине извршавања (сличне Rust-у)
и једноставности развоја (сличне Python-у).
Циљ је био демонстрирати како конкурентно извршавање може бити постигнуто уз минималан број линија кода.

=== Структура програма

Програм је организован у неколико целина:

1. *Модел система* — дефинише структуре `Params`, `State` и `Sample`, које представљају параметре система, тренутно стање и узорак података током симулације.  
2. *Нумеричка интеграција* — реализована методом _Runge–Kutta_ четвртог реда кроз функцију `rk4Step`.  
3. *Енергетска функција* — израчунава кинетичку и потенцијалну енергију система за сваки корак.  
4. *Паралелна симулација* — организована преко *worker pool* модела користећи _goroutines_ и _channels_.  
5. *Упис резултата* — свака симулација резултате уписује у засебан CSV фајл ради касније анализе.

#figure(
  ```go
  func rk4Step(p Params, s State, dt float64) State {
      k1 := deriv(p, s)
      s2 := State{Th1: s.Th1 + 0.5*dt*k1.Th1, Om1: s.Om1 + 0.5*dt*k1.Om1,
                  Th2: s.Th2 + 0.5*dt*k1.Th2, Om2: s.Om2 + 0.5*dt*k1.Om2}
      k2 := deriv(p, s2)
      s3 := State{Th1: s.Th1 + 0.5*dt*k2.Th1, Om1: s.Om1 + 0.5*dt*k2.Om1,
                  Th2: s.Th2 + 0.5*dt*k2.Th2, Om2: s.Om2 + 0.5*dt*k2.Om2}
      k3 := deriv(p, s3)
      s4 := State{Th1: s.Th1 + dt*k3.Th1, Om1: s.Om1 + dt*k3.Om1,
                  Th2: s.Th2 + dt*k3.Th2, Om2: s.Om2 + dt*k3.Om2}
      k4 := deriv(p, s4)
      return State{
          Th1: s.Th1 + dt*(k1.Th1+2*k2.Th1+2*k3.Th1+k4.Th1)/6.0,
          Om1: s.Om1 + dt*(k1.Om1+2*k2.Om1+2*k3.Om1+k4.Om1)/6.0,
          Th2: s.Th2 + dt*(k1.Th2+2*k2.Th2+2*k3.Th2+k4.Th2)/6.0,
          Om2: s.Om2 + dt*(k1.Om2+2*k2.Om2+2*k3.Om2+k4.Om2)/6.0,
      }
  }
  ``` ,
  caption: [Нумеричка интеграција методом Runge–Kutta четвртог реда у Go-у]
)

=== Паралелна имплементација

Паралелизација се заснива на *worker pool* моделу где сваки *радник* извршава независну симулацију 
са различитим почетним условима.  
Послови се шаљу преко _jobs_ канала, а резултати се прикупљају преко _results_ канала.  
На овај начин се постиже висок степен искоришћења процесора уз минималан _overhead_.

#figure(
  ```go
  func worker(p Params, dt float64, steps int, recordEvery int, outDir string,
              jobs <-chan job, results chan<- result) {
      for jb := range jobs {
          samples := simulate(p, jb.s0, dt, steps, recordEvery)
          path := fmt.Sprintf("%s/run_%04d.csv", outDir, jb.id)
          err := writeCSV(path, samples)
          results <- result{id: jb.id, err: err, path: path}
      }
  }
  ``` ,
  caption: [_Worker_ функција]
)

У главном делу програма, број радних горутина (_workers_) може бити експлицитно дефинисан 
или се аутоматски поставити на вредност `runtime.GOMAXPROCS(0)`, која представља број доступних језгара.  
Послови се креирају тако што се свакој симулацији задају благо различити почетни углови, 
чиме се демонстрира хаотична осетљивост система.

=== Карактеристике и предности

- Модел конкурентности у _Go_-у је изузетно једноставан — стварање хиљада _goroutine_-а има занемарљив трошак у меморији.  
- Комуникација преко _channels_ обезбеђује безбедну синхронизацију без експлицитних закључавања.  
- Уз једноставну синтаксу, _Go_ нуди стабилне перформансе које се у овом систему приближавају Rust-у.