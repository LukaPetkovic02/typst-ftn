= Анализа резултата

У овом поглављу приказани су резултати експеримената извршених над имплементацијама
двоструког клатна у _Python_, _Rust_ и _Go_ програмским језицима. Циљ анализе је да се
упореде перформансе, скалабилност и ефикасност све три верзије програма при различитом
броју процеса, као и да се утврди у којој мери резултати одговарају теоријским моделима
паралелног израчунавања.

== Окружење и методологија тестирања

Сви експерименти су спроведени на лаптопу са карактеристикама датим у табели @tbl:laptop 
#figure(
    table(
        columns: 2,
        align: (col, row) => (left,left,).at(col),
        inset: 6pt,
        [Процесор], [_AMD Ryzen 7 5700U_],
        [Радни такт], [1.80 GHz],
        [_Cache_ меморија], [L2 - 4MB, L3 - 8MB],
        [RAM меморија],[8GB],
        [Оперативни систем],[_Windows_ 11]
    ),
    caption: [Конфигурација лаптопа]
)<tbl:laptop>

Симулације су извођене RK4 методом са временским кораком _dt=0.001_ током 60 секунди, односно 60000 корака.
Свака трајекторија представља један скуп почетних услова, а _ensemble_ паралелизација омогућава извођење више
различитих трајекторија истовремено. Сва мерења су понављана 30 пута, а у анализи се користи средња вредност
времена извршавања као и стандардна девијација. Што се тиче стања сваког клатна, онo се чува у одговарајућем _csv_ фајлу
са 6 основних променљивих (колона): t - протекло време, θ₁, θ₂, ω₁, ω₂ и _energy_ - укупна енергија система.

== Анализа јаког и слабог скалирања у програмском језику _Python_

=== Јако скалирање

На слици @fig:python_strong и табели @tbl:python_strong_t су приказани резултати јаког скалирања.
На табели се јасно уочава да време извршавања опада са повећањем броја процеса, што потврђује да
паралелизација успешно распоређује посао између процеса. Убрзање расте приближно линеарно за мали
број процеса, али се касније јавља одступање од идеалне линије скалирања. Ово понашање је очекивано
ако узмемо у обзир ограничења _Python_ језика, и трошкове операција читања и писања података у csv фајлове.

#figure(image("../slike/python_strong.png", width: auto),
    caption: [
      Јако скалирање (_Python_)
    ]
  )<fig:python_strong>

#figure(
    table(
        columns: 5,
        align: (col, row) => (left,left,left,left,left).at(col),
        inset: 6pt,
        [број процесора], [време извршавања],[стандардна девијација],[убрзање],[теоријско убрзање (Амдал)],
        [1], [9.57s],[0.103s],[1.00],[1.00],
        [2], [6.45s],[0.271s],[1.48],[1.90],
        [4],[4.64s],[0.157s],[2.06],[3.48],
        [8],[3.18s],[0.049s],[3.01],[5.92],
        [16],[2.62s],[0.056s],[3.65],[9.14]
    ),
    caption: [Резултати јаког скалирања (_Python_)]
)<tbl:python_strong_t>

=== Слабо скалирање

Резултати слабог скалирања приказани су на слици @fig:python_weak и у табели @tbl:python_weak_t.
У овом експерименту укупан посао је повећаван тако да сваки процес извршава 60000 интеграционих корака.
На тај начин се проверава колико добро се систем понаша при већем оптерећењу. У савршеном случају, укупно време извршавања
би остало исто при било ком броју процеса. У нашем случају, време се благо повећава, што је последица _Python_-овог _multiprocessing_
модела.

#figure(image("../slike/python_weak.png", width: auto),
    caption: [
      Слабо скалирање (_Python_)
    ]
  )<fig:python_weak>

#figure(
    table(
        columns: 6,
        align: (col, row) => (left,left,left,left,left,left).at(col),
        inset: 6pt,
        [број процесора], [укупан посао],[време извршавања],[стандардна девијација],[скалирано убрзање],[теоријско убрзање (Густафсон)],
        [1], [60000],[9.63s],[0.07],[1.00],[1.00],
        [2], [120000],[11.22s],[0.78],[1.71],[1.95],
        [4],[240000],[12.87s],[1.62],[2.99],[3.85],
        [8],[480000],[19.53s],[0.36],[3.94],[7.65],
        [16],[960000],[26.04s],[0.38],[5.92],[15.25]
    ),
    caption: [Резултати слабог скалирања (_Python_)]
)<tbl:python_weak_t>

== Анализа јаког и слабог скалирања у програмском језику _Rust_

=== Јако скалирање

Слика @fig:rust_strong и табела @tbl:rust_strong_t описују јако скалирање. Као и у _Python_-у, симулирали смо 16 независних трајекторија, сваку са
60000 корака, при различитом броју нити. Видимо да се убрзање креће око јединице, што значи да се додавањем нових
нити не постиже реална добит у брзини.

Иако _Rust_ није постигао значајно јако скалирање, што је видљиво са графика, треба нагласити да је _Rust_ *компајлирани језик*
познат по високој ефикасности и минималним режијским трошковима. Намерно је узет исти укупан посао као и у _Python_-у како би
указали на драстично мање време извршавања.

Без обзира на одступање од Амдалове криве, _Rust_ је показао врхунске апсолутне перформансе, што га чини погодним за израду научних симулација високих перформанси.

#figure(image("../slike/rust_strong.png", width: auto),
    caption: [
      Јако скалирање (_Rust_)
    ]
  )<fig:rust_strong>

#figure(
    table(
        columns: 5,
        align: (col, row) => (left,left,left,left,left).at(col),
        inset: 6pt,
        [број процесора], [време извршавања],[стандардна девијација],[убрзање],[теоријско убрзање (Амдал)],
        [1], [0.0099s],[0.0408s],[1.00],[1.00],
        [2], [0.0115s],[0.0810s],[0.86],[1.90],
        [4],[0.0102s],[0.0513s],[0.97],[3.48],
        [8],[0.0105s],[0.0631s],[0.95],[5.92],
        [16],[0.0111s],[0.0005s],[0.89],[9.14]
    ),
    caption: [Резултати јаког скалирања (_Rust_)]
)<tbl:rust_strong_t>

=== Слабо скалирање

Резултате слабог скалирања можемо видети на слици @fig:rust_weak и табели @tbl:rust_weak_t.
На графику се може уочити да се експериментална крива налази непосредно испод Густафсонове линије, 
што је у складу са очекивањима. Разлика између теоријског и стварног убрзања потиче углавном од режијских трошкова 
синхронизације и ограничења I/O (_input/output_) подсистема, који постају релевантни тек при великом броју нити.

За 16 нити, измерено скалирано убрзање износи 14.32, док теоријска вредност по Густафсоновом моделу износи 15.25, 
што представља преко 93% идеалног резултата. Ово показује да _Rust_ имплементација приближава стварне перформансе теоријским границама.

Закључно, _Rust_ се у овом експерименту показао као високо ефикасан језик за паралелну симулацију, 
са готово идеалним слабим скалирањем и минималним осцилацијама у времену извршавања.

#figure(image("../slike/rust_weak.png", width: auto),
    caption: [
      Слабо скалирање (_Rust_)
    ]
  )<fig:rust_weak>

#figure(
    table(
        columns: 5,
        align: (col, row) => (left,left,left,left,left).at(col),
        inset: 6pt,
        [број процесора], [укупан посао],[време извршавања],[скалирано убрзање],[теоријско убрзање (Густафсон)],
        [1], [60000],[0.0092s],[1.00],[1.00],
        [2], [120000],[0.0101s],[1.82],[1.95],
        [4],[240000],[0.0103s],[3.56],[3.85],
        [8],[480000],[0.0105s],[7.02],[7.65],
        [16],[960000],[0.0112s],[14.32],[15.25]
    ),
    caption: [Резултати слабог скалирања (_Rust_)]
)<tbl:rust_weak_t>

== Анализа јаког и слабог скалирања у програмском језику _Go_

=== Јако скалирање

Јако скалирање у _Go_-у и његове резултате (слика @fig:go_strong) можемо видети у наставку.

#figure(image("../slike/go_strong.png", width: auto),
    caption: [
      Јако скалирање (_Go_)
    ]
  )<fig:go_strong>

#figure(
    table(
        columns: 5,
        align: (col, row) => (left,left,left,left,left).at(col),
        inset: 6pt,
        [број процесора], [време извршавања],[стандардна девијација],[убрзање],[теоријско убрзање (Амдал)],
        [1], [4.8022s],[0.051s],[1.00],[1.00],
        [2], [2.4633s],[0.037s],[1.95],[1.97],
        [4],[1.4089s],[0.028s],[3.41],[3.77],
        [8],[0.8542s],[0.019s],[5.62],[7.00],
        [16],[0.6952s],[0.022s],[6.91],[9.71]
    ),
    caption: [Резултати јаког скалирања (_Go_)]
)<tbl:go_strong_t>

Резултати приказани у табели @tbl:go_strong_t показују да ова имплементација постиже боље јако скалирање у односу на _Python_ и _Rust_. 
При фиксном укупном послу од 16 симулација двоструког клатна, време извршавања опада скоро линеарно са порастом броја процеса. 
Највећи пад времена примећује се при преласку са једног на два процеса, док се даљим повећањем броја процеса добија све мањи релативни добитак, 
што је у складу са Амдаловим законом.

За 16 процеса остварено је убрзање од 6.91, што представља приближно 71% теоријског убрзања (9.71) израчунатог за проценат паралелизованог кода _p = 97%_. 
Времена извршавања су стабилна и показују минималну стандардну девијацију, што указује на стабилно управљање процесима унутар _Go runtime_-а.

=== Слабо скалирање

График слабог скалирања видимо на слици @fig:go_weak
#figure(image("../slike/go_weak.png", width: auto),
    caption: [
      Слабо скалирање (_Go_)
    ]
  )<fig:go_weak>


#figure(
table(
columns: 6,
align: (col, row) => (left,left,left,left,left,left).at(col),
inset: 6pt,
[број процеса], [укупан посао (број путања)], [време извршавања], [стандардна девијација], [скалирано убрзање], [теоријско убрзање (Густафсон)],
[1], [2], [0.6321s], [0.013s], [1.00], [1.00],
[2], [4], [0.6511s], [0.015s], [1.94], [1.95],
[4], [8], [0.7243s], [0.018s], [3.49], [3.85],
[8], [16], [0.9153s], [0.021s], [5.52], [7.65],
[16], [32], [1.3220s], [0.029s], [7.66], [15.25]
),
caption: [Резултати слабог скалирања (_Go_)]
)<tbl:go_weak_t>

Резултати приказани у табели @tbl:go_weak_t показују да Go имплементација постиже *успешно слабо скалирање*, са постепеним растом времена извршавања 
како се број трајекторија повећава пропорционално броју процеса.
Иако би у идеалном случају време извршавања остало константно, уочено је благо повећање — од 0.63 s на једном процесу до 1.32 s на шеснаест процеса. 
Ово повећање је очекивано, јер са већим бројем процеса расту и режијски трошкови синхронизације и расподеле посла.

Скалирано убрзање расте скоро линеарно до осам процеса, након чега долази до благог засићења. 
Најбољи однос добијен је за осам процеса, где је експериментално убрзање 5.52, што представља приближно 72% теоријског Густафсоновог убрзања.

Резултати потврђују да _Go_ захваљујући горутинама и ефикасном _scheduler_-у веома добро распоређује додатни посао између 
процеса без значајног губитка перформанси.
